<!DOCTYPE html>
<html>
		<meta charset="utf-8" />

		<title>sat jan 8th: secret location bridge rave</title>
		<meta property="og:title" content="sat mar 7: secret location bridge rave" />
		<meta name="description" property="og:description" content="celebrating the cross-pollination of global club sounds.">
		<meta property="og:type" content="website" />
		<meta property="og:url" content="https://niceweather.club/" />

		<meta name="viewport" content="width=device-width" />

		<style>
			@font-face {
				font-family: 'Inconsolata';
				font-style: normal;
				font-weight: 400;
				src: local('Inconsolata'), url(inconsolata-v12.woff2) format('woff2');
			}

			body {
				font-family: "Inconsolata", monospace;
				font-size: calc(1em + 1vw);
				width: 100vw;
				height: 100vh;
				margin: 0px;
				/* background-image: url('tamar_images/1.png');
				background-position: center center;
				background-attachment: fixed;
				background-size: auto 100%;
				background-repeat: no-repeat; */
				display: flex;
				justify-content: center;
			}

			#main-container {
				position: absolute;
				width: 90%;
				overflow: auto;
				height: 100%;
				z-index: 1;
			}

			canvas {
				/* display: block; */
				position: fixed;
				height: 100%;
				width: auto;
				left: 50%;
				top: 50%;
				transform: translate(-50%, -50%);
				z-index: 0;
			}

			a {
				color: rgb(211, 209, 209);
				text-decoration: underline;
			}

			ul {
				padding: 0;
			}

			ol li {
				margin-top: 1em;
			}

			ul li {
				display: inline-block;
				font-weight: bold;
			}

			ul li:not(:last-child):after {
				content: " +";
				font-weight: normal;
			}

		</style>
	</head>
	<body>
		<script type="x-shader/x-vertex" id="vs">
			attribute vec3 position;
			varying vec2 vTexCoord;
		
			void main() {
				vTexCoord = (position.xy + 1.0) * 0.5;
				vTexCoord.y = 1.0 - vTexCoord.y;
				gl_Position = vec4(position, 1.0);
			}
		</script>
		
		<script type="x-shader/x-fragment" id="fs">
			precision mediump float;
			uniform float time;
			uniform sampler2D texture;
			varying vec2 vTexCoord;
		
			float frequency = 0.01;
			float amplitude = 0.01;
		
			void main() {
				float distortion = sin(gl_FragCoord.x * frequency + time) * amplitude;
				vec4 samplerColor = texture2D(texture, vec2(vTexCoord.x + distortion, vTexCoord.y + distortion * 0.5));
				gl_FragColor = samplerColor;
			}
		</script>
		
		<div id="main-container">
			<h1>bridge rave: sat jan 8th</h1>
	
			<h3>
			celebrating the cross-pollination of global club sounds
			</h3>
	
	
			<ul>
				<h4>djs:</h4>
				<li>oxymoron</li>
				<li>hyundai excel</li>
				<li>egomaniax</li>
				<li>dj burnout</li>
				<li>asian boyfriend</li>
				<li>inci90</li>
			</ul>
	
			<ul>
			<h4>time:</h4>
				<li>11PM - 6AM</li>
			</ul>

			<ul>
				<h4>location:</h4>
					<li>co-ordinates will be posted here 9pm</li>
				</ul>
	
			<p>This event is operating on stolen land. We pay our respects to the Wurundjeri peoples of the Kulin Nation, and to their elders; past, present and future. Sovereignty never ceded. </p>
	
			<!-- <p>
				sincerely,<br />
				your friends at
				<a href="https://niceweather.club/">nice weather club</a>
			</p> -->
		</div>

		<script>
			const TEXTURE_SRC = 'tamar_images/1.png';

			function init(img) {
				initWebGL();

				const program = createProgram('vs', 'fs');
				if (!program) return;

				// 頂点座標
				const position = [
				-1, 1, 0,
				-1, -1, 0,
				1, 1, 0,
				1, -1, 0];

				const positionCount = position.length / 3;

				// attribute 定義
				createAttribute({
					position: {
						stride: 3,
						value: position } },

				program);

				// attribute 設定
				setAttribute('position');

				// uniform 定義
				createUniform({
					time: {
						type: '1f' },

					texture: {
						type: '1i' } },

				program);

				// テクスチャ設定
				createTexture(img);
				setUniform('texture', 0);

				clearColor(0, 0, 0, 1);

				initSize(img.width, img.height);

				start(time => {
					// uniform 設定
					setUniform('time', time / 800);
				}, 'TRIANGLE_STRIP', positionCount);
			}

			loadImage(TEXTURE_SRC, init);

			// --------------------
			// library
			// --------------------

			let canvas, gl;
			const attributes = {};
			const uniforms = {};

			function initWebGL() {
				canvas = document.createElement('canvas');
				gl = canvas.getContext('webgl');
				document.body.appendChild(canvas);
			}

			function createShader(id) {
				const scriptElement = document.getElementById(id);
				const shader = (() => {
					switch (scriptElement.type) {
						case 'x-shader/x-vertex':
							return gl.createShader(gl.VERTEX_SHADER);
						case 'x-shader/x-fragment':
							return gl.createShader(gl.FRAGMENT_SHADER);
						default:
							return;}

				})();

				gl.shaderSource(shader, scriptElement.textContent);
				gl.compileShader(shader);

				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
					console.error(gl.getShaderInfoLog(shader));
					return;
				}

				return shader;
			}

			function createProgram(vsId, fsId) {
				const program = gl.createProgram();
				gl.attachShader(program, createShader(vsId));
				gl.attachShader(program, createShader(fsId));
				gl.linkProgram(program);

				if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
					console.error(gl.getProgramInfoLog(program));
					return;
				}

				gl.useProgram(program);
				return program;
			}

			function createAttribute(data, program) {
				Object.keys(data).forEach(key => {
					const { stride, value } = data[key];
					attributes[key] = {
						location: gl.getAttribLocation(program, key),
						stride,
						vbo: createVbo(value) };

				});
			}

			function createVbo(data) {
				const vbo = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(data), gl.STATIC_DRAW);
				gl.bindBuffer(gl.ARRAY_BUFFER, null);
				return vbo;
			}

			function setAttribute(name) {
				const { vbo, location, stride } = attributes[name];

				gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
				gl.enableVertexAttribArray(location);
				gl.vertexAttribPointer(location, stride, gl.FLOAT, false, 0, 0);
			}

			function createUniform(data, program) {
				Object.keys(data).forEach(key => {
					const uniform = data[key];
					uniforms[key] = {
						location: gl.getUniformLocation(program, key),
						type: `uniform${uniform.type}` };

				});
			}

			function setUniform(name, value) {
				const uniform = uniforms[name];
				if (!uniform) return;

				gl[uniform.type](uniform.location, value);
			}

			function bindTexture(texture) {
				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			}

			function createTexture(img) {
				const texture = gl.createTexture();
				gl.bindTexture(gl.TEXTURE_2D, texture);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
				gl.generateMipmap(gl.TEXTURE_2D);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
				gl.bindTexture(gl.TEXTURE_2D, null);

				gl.activeTexture(gl.TEXTURE0);
				gl.bindTexture(gl.TEXTURE_2D, texture);
			}

			function clearColor(...args) {
				gl.clearColor(...args);
			}

			function loadImage(src, callback) {
				const img = new Image();
				img.addEventListener('load', () => {
					callback(img);
				});
				img.crossOrigin = 'anonymous';
				img.src = src;
			}
			function setSize (width = window.innerWidth, height = window.innerHeight) {
				const windowRatio = window.innerWidth / window.innerHeight
				const imgRatio = width / height

				if (imgRatio >= windowRatio) {
					canvas.width = window.innerWidth
					canvas.height = window.innerWidth / imgRatio
				} else {
					canvas.height = window.innerHeight
					canvas.width = window.innerHeight * imgRatio
				}

				gl.viewport(0, 0, canvas.width, canvas.height)

				setUniform('resolution', [canvas.width, canvas.height])
			}

			function initSize(width, height) {
				setSize(width, height);
				window.addEventListener('resize', () => {
					setSize(width, height);
				});
			}

			function start(draw, mode, count) {
  		function render(time) {
    	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    draw(time);

    gl.drawArrays(gl[mode], 0, count);

    requestAnimationFrame(render);
  	}
  requestAnimationFrame(render);
	}
		</script>
	</body>
</html>
